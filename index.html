<head>
    <title>The Myth of Zulda: Lonk's Age</title>
    <style>
        body {
            display: grid;
            place-items: center;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas" width="960" height="864"></canvas>
    <script>
        /**
         * @typedef {Object} GameConfig
         * @property {number} TIMESTEP - The fixed time step (in milliseconds) for game logic updates.
         * @property {number} MAX_DELTA_TIME - The maximum allowed delta time (in milliseconds) to prevent "spiral of death" on performance dips.
         * @property {number} MAX_UPDATES_PER_FRAME - The maximum number of game logic updates that can occur in a single frame.
         * @property {number} SPRITE_WIDTH - The width of a single sprite in pixels.
         * @property {number} SPRITE_HEIGHT - The height of a single sprite in pixels.
         * @property {number} FPS_UPDATE_INTERVAL - The interval (in milliseconds) at which the FPS counter is updated.
         * @property {number} CANVAS_SCALE - The scaling factor for the canvas resolution.
         * @property {number} LONK_COLLISION_OFFSET_X - X offset for Lonk's collision box from left edge.
         * @property {number} LONK_COLLISION_OFFSET_Y - Y offset for Lonk's collision box from top edge.
         * @property {number} LONK_COLLISION_WIDTH_REDUCTION - Amount to reduce Lonk's sprite width for collision.
         * @property {number} LONK_COLLISION_HEIGHT_REDUCTION - Amount to reduce Lonk's sprite height for collision.
         */
        const GameConfig = Object.freeze({
            TIMESTEP: 1000 / 30,
            MAX_DELTA_TIME: 250,
            MAX_UPDATES_PER_FRAME: 5,
            SPRITE_WIDTH: 16,
            SPRITE_HEIGHT: 16,
            FPS_UPDATE_INTERVAL: 1000, // Update FPS every 1 second
            CANVAS_SCALE: 6, // Scale up the canvas
            LONK_COLLISION_OFFSET_X: 4,
            LONK_COLLISION_OFFSET_Y: 6,
            LONK_COLLISION_WIDTH_REDUCTION: 8, // 4 from each side (16 - 8 = 8 actual width)
            LONK_COLLISION_HEIGHT_REDUCTION: 8, // 6 from top + 2 from bottom (16 - 8 = 8 actual height)
            GAME_BAR_HEIGHT: 1, // Offset for the game bar
        });

        /**
         * Defines the cardinal directions as immutable constants.
         * @readonly
         * @enum {string}
         */
        const Directions = Object.freeze({
            UP: 'up',
            DOWN: 'down',
            LEFT: 'left',
            RIGHT: 'right'
        });

        /**
         * Manages the loading and retrieval of game assets like images.
         */
        class AssetManager {
            /**
             * Creates an instance of AssetManager.
             */
            constructor() {
                /**
                 * A dictionary to store loaded assets, keyed by their names.
                 * @type {Object.<string, HTMLImageElement>}
                 */
                this.assets = {};
                /**
                 * An array to hold promises for asset loading.
                 * @type {Promise<void>[]}
                 */
                this.loadPromises = [];
            }

            /**
             * Loads an image asset.
             * @param {string} name - The name to associate with the loaded image.
             * @param {string} path - The URL path to the image file.
             * @returns {HTMLImageElement} The Image object being loaded.
             */
            loadImage(name, path) {
                const img = new Image();
                img.src = path;
                const promise = new Promise((resolve, reject) => {
                    img.onload = () => {
                        this.assets[name] = img;
                        resolve();
                    };
                    img.onerror = () => {
                        console.error(`Failed to load image: ${path}`);
                        reject(new Error(`Failed to load image: ${path}`));
                    };
                });
                this.loadPromises.push(promise);
                return img;
            }

            /**
             * Retrieves a loaded asset by its name.
             * @param {string} name - The name of the asset to retrieve.
             * @returns {HTMLImageElement | undefined} The loaded image asset, or undefined if not found.
             */
            getAsset(name) {
                return this.assets[name];
            }

            /**
             * Waits for all loaded assets to complete loading.
             * @returns {Promise<void>} A promise that resolves when all assets are loaded.
             */
            async loadAll() {
                await Promise.all(this.loadPromises);
                console.log("All assets loaded!");
            }
        }

        /**
         * Manages keyboard input for the game.
         */
        class InputManager {
            /**
             * Creates an instance of InputManager.
             */
            constructor() {
                /**
                 * A dictionary to track the state of keys (true if pressed, false if released).
                 * Keys are stored in lowercase.
                 * @type {Object.<string, boolean>}
                 */
                this.keys = {};
                /**
                 * A mapping from abstract actions (using Directions enum) to the primary key that triggers them.
                 * @type {Object.<Directions, string>}
                 */
                this.actionMap = {
                    [Directions.UP]: 'w',
                    [Directions.DOWN]: 's',
                    [Directions.LEFT]: 'a',
                    [Directions.RIGHT]: 'd',
                };
                this.addEventListeners();
            }

            /**
             * Adds event listeners for keyboard keydown and keyup events.
             * @private
             */
            addEventListeners() {
                document.addEventListener('keydown', (/** @type {KeyboardEvent} */ e) => {
                    this.keys[e.key.toLowerCase()] = true;
                });
                document.addEventListener('keyup', (/** @type {KeyboardEvent} */ e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
            }

            /**
             * Checks if an abstract action (e.g., 'up', 'down') is currently active.
             * @param {Directions} action - The action to check (e.g., Directions.UP, Directions.LEFT).
             * @returns {boolean} True if any key mapped to the action is pressed, false otherwise.
             */
            isActionActive(action) {
                return !!this.keys[this.actionMap[action]];
            }
        }

        /**
         * Represents the main player character, Lonk.
         */
        class Lonk {
            /**
             * Creates an instance of Lonk.
             * @param {number} x - The initial X coordinate of Lonk.
             * @param {number} y - The initial Y coordinate of Lonk.
             */
            constructor(x, y) {
                /** @type {number} */
                this.x = x;
                /** @type {number} */
                this.y = y;
                /** @type {number} */
                this.prevX = x; // Store previous X for interpolation
                /** @type {number} */
                this.prevY = y; // Store previous Y for interpolation
                /** @type {number} */
                this.speed = 2;
                /**
                 * The current direction Lonk is facing.
                 * @type {Directions}
                 */
                this.direction = Directions.DOWN;
                /**
                 * The current animation frame for Lonk.
                 * @type {0 | 1}
                 */
                this.frame = 0;
                /**
                 * The delay (in game updates) between animation frames.
                 * @type {number}
                 */
                this.frameDelay = 3;
                /**
                 * Counter for frame delay.
                 * @type {number}
                 */
                this.frameCounter = 0;
            }

            /**
             * Updates Lonk's position and animation based on input.
             * @param {InputManager} inputManager - The input manager instance.
             * @param {number[][]} backgroundMap - The 2D array representing the game's background tiles.
             * @param {number[]} solidTiles - An array of sprite IDs that are considered solid.
             * @param {number} canvasWidth - The width of the game canvas (unscaled).
             * @param {number} canvasHeight - The height of the game canvas (unscaled).
             */
            update(inputManager, backgroundMap, solidTiles, canvasWidth, canvasHeight) {
                // Store current position as previous before updating
                this.prevX = this.x;
                this.prevY = this.y;

                let moveX = 0;
                let moveY = 0;

                if (inputManager.isActionActive(Directions.UP)) {
                    moveY -= this.speed;
                } else if (inputManager.isActionActive(Directions.DOWN)) {
                    moveY += this.speed;
                }
                
                if (inputManager.isActionActive(Directions.LEFT)) {
                    moveX -= this.speed;
                } else if (inputManager.isActionActive(Directions.RIGHT)) {
                    moveX += this.speed;
                }

                // Set direction based on priority: Left/Right takes precedence over Up/Down
                if (inputManager.isActionActive(Directions.LEFT)) {
                    this.direction = Directions.LEFT;
                } else if (inputManager.isActionActive(Directions.RIGHT)) {
                    this.direction = Directions.RIGHT;
                } else if (inputManager.isActionActive(Directions.UP)) {
                    this.direction = Directions.UP;
                } else if (inputManager.isActionActive(Directions.DOWN)) {
                    this.direction = Directions.DOWN;
                }


                // Normalize diagonal movement
                if (moveX !== 0 && moveY !== 0) {
                    const diagonalSpeed = Math.sqrt(2);
                    moveX /= diagonalSpeed;
                    moveY /= diagonalSpeed;
                }

                // Clamp potential new position to unscaled canvas bounds
                const newX = Math.max(0, Math.min(this.x + moveX, canvasWidth - GameConfig.SPRITE_WIDTH));
                const newY = Math.max(0, Math.min(this.y + moveY, canvasHeight - GameConfig.SPRITE_HEIGHT));

                // Collision detection
                const noCollisionX = !this.checkCollision(newX, this.y, backgroundMap, solidTiles);
                const noCollisionY = !this.checkCollision(this.x, newY, backgroundMap, solidTiles);
                if (noCollisionX && noCollisionY) {
                    this.x = newX;
                    this.y = newY;
                }

                // Only animate if Lonk actually moved AND didn't hit a wall
                if ((moveX !== 0 || moveY !== 0) && noCollisionX && noCollisionY) {
                    this.frameCounter++;
                    if (this.frameCounter >= this.frameDelay) {
                        this.frameCounter = 0;
                        this.frame = (this.frame + 1) % 2;
                    }
                }
            }

            /**
             * Checks for collision with solid background tiles at a given potential position.
             * @param {number} potentialX - The potential X coordinate of Lonk.
             * @param {number} potentialY - The potential Y coordinate of Lonk.
             * @param {number[][]} backgroundMap - The 2D array representing the game's background tiles.
             * @param {number[]} solidTiles - An array of sprite IDs that are considered solid.
             * @returns {boolean} True if a collision is detected, false otherwise.
             */
            checkCollision(potentialX, potentialY, backgroundMap, solidTiles) {
                // Collision box adjusted for sprite (e.g., Lonk is 16x16 but collision is smaller)
                const lonkLeft = potentialX + GameConfig.LONK_COLLISION_OFFSET_X;
                const lonkTop = potentialY + GameConfig.LONK_COLLISION_OFFSET_Y;
                const lonkRight = potentialX + GameConfig.SPRITE_WIDTH - GameConfig.LONK_COLLISION_OFFSET_X;
                const lonkBottom = potentialY + GameConfig.SPRITE_HEIGHT - (GameConfig.LONK_COLLISION_HEIGHT_REDUCTION - GameConfig.LONK_COLLISION_OFFSET_Y);

                // Determine the range of tiles Lonk is currently overlapping or about to overlap
                const startTileX = Math.floor(lonkLeft / GameConfig.SPRITE_WIDTH);
                const endTileX = Math.floor(lonkRight / GameConfig.SPRITE_WIDTH);
                const startTileY = Math.floor(lonkTop / GameConfig.SPRITE_HEIGHT);
                const endTileY = Math.floor(lonkBottom / GameConfig.SPRITE_HEIGHT);

                for (let row = startTileY; row <= endTileY; row++) {
                    for (let col = startTileX; col <= endTileX; col++) {
                        // Ensure tile coordinates are within the map boundaries
                        if (row >= 0 && row < backgroundMap.length && col >= 0 && col < backgroundMap[row].length) {
                            const tileId = backgroundMap[row][col];
                            if (solidTiles.includes(tileId)) {
                                return true; // Collision detected with a solid tile
                            }
                        }
                    }
                }
                return false; // No collision
            }


            /**
               * Draws Lonk on the canvas with interpolation.
               * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
               * @param {HTMLImageElement} lonkSpritesheet - The spritesheet image for Lonk.
               * @param {number} interpolation - The interpolation factor (0 to 1) for smooth rendering.
               */
            draw(ctx, lonkSpritesheet, interpolation) {
                let sourceX = 0;
                let flipHorizontal = false;

                switch (this.direction) {
                    case Directions.DOWN:
                        sourceX = 0 * GameConfig.SPRITE_WIDTH;
                        if (this.frame === 1) {
                            flipHorizontal = true; // For down-facing, frame 1 is a mirrored version
                        }
                        break;
                    case Directions.UP:
                        sourceX = 1 * GameConfig.SPRITE_WIDTH;
                        if (this.frame === 1) {
                            flipHorizontal = true; // For up-facing, frame 1 is a mirrored version
                        }
                        break;
                    case Directions.LEFT:
                        sourceX = (2 + this.frame) * GameConfig.SPRITE_WIDTH; // Frames 2 and 3 are for left
                        break;
                    case Directions.RIGHT:
                        sourceX = (2 + this.frame) * GameConfig.SPRITE_WIDTH; // Frames 2 and 3 are for right, but flipped
                        flipHorizontal = true;
                        break;
                }

                // Calculate interpolated position (unscaled) and round to the nearest integer
                const interpolatedX = Math.round(this.prevX + (this.x - this.prevX) * interpolation);
                const interpolatedY = Math.round(this.prevY + (this.y - this.prevY) * interpolation);

                // Apply scaling for drawing and ensure integer pixel positions
                const scaledX = interpolatedX * GameConfig.CANVAS_SCALE;
                const scaledY = (interpolatedY + GameConfig.GAME_BAR_HEIGHT * GameConfig.SPRITE_HEIGHT) * GameConfig.CANVAS_SCALE;
                const scaledSpriteWidth = GameConfig.SPRITE_WIDTH * GameConfig.CANVAS_SCALE;
                const scaledSpriteHeight = GameConfig.SPRITE_HEIGHT * GameConfig.CANVAS_SCALE;


                ctx.save();
                if (flipHorizontal) {
                    // Translate to the center of the scaled sprite, scale horizontally, then draw
                    ctx.translate(scaledX + scaledSpriteWidth / 2, scaledY + scaledSpriteHeight / 2);
                    ctx.scale(-1, 1);
                    ctx.drawImage(
                        lonkSpritesheet,
                        sourceX, 0,
                        GameConfig.SPRITE_WIDTH, GameConfig.SPRITE_HEIGHT, // Source (unscaled)
                        -scaledSpriteWidth / 2, -scaledSpriteHeight / 2,
                        scaledSpriteWidth, scaledSpriteHeight // Destination (scaled)
                    );
                } else {
                    ctx.drawImage(
                        lonkSpritesheet,
                        sourceX, 0,
                        GameConfig.SPRITE_WIDTH, GameConfig.SPRITE_HEIGHT, // Source (unscaled)
                        scaledX, scaledY, // Destination (scaled)
                        scaledSpriteWidth, scaledSpriteHeight // Destination (scaled)
                    );
                }
                ctx.restore();
            }
        }

        /**
         * Handles all rendering operations for the game.
         */
        class Renderer {
            /**
             * Creates an instance of Renderer.
             * @param {HTMLCanvasElement} canvas - The HTML canvas element to draw on.
             * @param {HTMLImageElement} backgroundSpritesheet - The spritesheet for background tiles.
             * @param {HTMLImageElement} lonkSpritesheet - The spritesheet for Lonk.
             */
            constructor(canvas, backgroundSpritesheet, lonkSpritesheet) {
                /** @type {HTMLCanvasElement} */
                this.canvas = canvas;
                /** @type {CanvasRenderingContext2D} */
                this.ctx = canvas.getContext('2d');
                /** @type {HTMLImageElement} */
                this.backgroundSpritesheet = backgroundSpritesheet;
                /** @type {HTMLImageElement} */
                this.lonkSpritesheet = lonkSpritesheet;

                this.ctx.imageSmoothingEnabled = false;
            }

            /**
             * Clears the entire canvas.
             */
            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            /**
             * Calculates the source X and Y coordinates on the spritesheet for a given sprite ID.
             * @param {number} spriteId - The ID of the sprite.
             * @returns {{sx: number, sy: number}} An object containing the source X (sx) and source Y (sy) coordinates.
             */
            getSpriteSourceCoords(spriteId) {
                const sx = (spriteId * GameConfig.SPRITE_WIDTH) % this.backgroundSpritesheet.width;
                const sy = Math.floor((spriteId * GameConfig.SPRITE_WIDTH) / this.backgroundSpritesheet.width) * GameConfig.SPRITE_HEIGHT;
                return { sx, sy };
            }

            /**
             * Draws the background tiles based on a 2D map array.
             * @param {number[][]} backgroundMap - A 2D array representing the background tiles, where each number is a sprite ID.
             */
            drawBackground(backgroundMap) {
                const scaledSpriteWidth = GameConfig.SPRITE_WIDTH * GameConfig.CANVAS_SCALE;
                const scaledSpriteHeight = GameConfig.SPRITE_HEIGHT * GameConfig.CANVAS_SCALE;

                for (let y = 0; y < backgroundMap.length; y++) {
                    for (let x = 0; x < backgroundMap[y].length; x++) {
                        const { sx, sy } = this.getSpriteSourceCoords(backgroundMap[y][x]);
                        this.ctx.drawImage(
                            this.backgroundSpritesheet,
                            sx, sy,
                            GameConfig.SPRITE_WIDTH, GameConfig.SPRITE_HEIGHT, // Source width and height (original sprite size)
                            x * scaledSpriteWidth, (y + GameConfig.GAME_BAR_HEIGHT) * scaledSpriteHeight,
                            scaledSpriteWidth, scaledSpriteHeight // Destination width and height (scaled)
                        );
                    }
                }
            }

            /**
             * Draws the Lonk character on the canvas.
             * @param {Lonk} lonk - The Lonk instance to draw.
             * @param {number} interpolation - The interpolation factor (0 to 1) for smooth rendering.
             */
            drawLonk(lonk, interpolation) {
                lonk.draw(this.ctx, this.lonkSpritesheet, interpolation);
            }

            /**
             * Draws the current Frames Per Second (FPS) on the canvas.
             * @param {number} fps - The current FPS value.
             */
            drawFPS(fps) {
                this.ctx.fillStyle = 'red';
                // Adjust font size and position for scaled canvas
                this.ctx.font = `${5 * GameConfig.CANVAS_SCALE}px Arial`;
                this.ctx.textAlign = 'right';
                this.ctx.fillText(`FPS: ${fps}`,
                    this.canvas.width - (5 * GameConfig.CANVAS_SCALE),
                    5 * GameConfig.CANVAS_SCALE
                );
            }
        }

        /**
         * Manages the main game loop, handling updates and rendering at a fixed timestep.
         */
        class GameLoop {
            /**
             * Creates an instance of GameLoop.
             * @param {function(): void} updateCallback - The function to call for game logic updates.
             * @param {function(number): void} renderCallback - The function to call for rendering.
             * @param {function(number): void} fpsCallback - The function to call when FPS updates.
             */
            constructor(updateCallback, renderCallback, fpsCallback) {
                /** @type {function(): void} */
                this.updateCallback = updateCallback;
                /** @type {function(number): void} */
                this.renderCallback = renderCallback;
                /** @type {function(number): void} */
                this.fpsCallback = fpsCallback;

                /** @type {number | null} */
                this.animationFrameId = null;
                /** @type {DOMHighResTimeStamp} */
                this.lastTime = 0;
                /** @type {number} */
                this.delta = 0;

                /** @type {number} */
                this.frameCount = 0;
                /** @type {DOMHighResTimeStamp} */
                this.lastFpsUpdateTime = 0;
                /** @type {number} */
                this.currentFps = 0;
            }

            /**
             * Starts the game loop.
             */
            start() {
                this.lastTime = performance.now();
                this.lastFpsUpdateTime = performance.now();
                this.delta = 0;
                this.animationFrameId = requestAnimationFrame(this.loop.bind(this));
            }

            /**
             * Stops the game loop.
             */
            stop() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }

            /**
             * The core game loop function.
             * @param {DOMHighResTimeStamp} now - The current time provided by requestAnimationFrame.
             * @private
             */
            loop(now) {
                const elapsed = now - this.lastTime;
                this.lastTime = now;
                this.delta += Math.min(elapsed, GameConfig.MAX_DELTA_TIME);

                let updatesCount = 0;
                while (this.delta >= GameConfig.TIMESTEP && updatesCount < GameConfig.MAX_UPDATES_PER_FRAME) {
                    this.updateCallback();
                    this.delta -= GameConfig.TIMESTEP;
                    updatesCount++;
                }

                // If we hit the max updates, reset delta to prevent accumulating too much time
                // This can happen if the game lags significantly
                if (updatesCount === GameConfig.MAX_UPDATES_PER_FRAME && this.delta >= GameConfig.TIMESTEP) {
                    this.delta = 0;
                }

                const interpolation = this.delta / GameConfig.TIMESTEP;
                this.renderCallback(interpolation);

                this.frameCount++;
                if (now - this.lastFpsUpdateTime >= GameConfig.FPS_UPDATE_INTERVAL) {
                    this.currentFps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdateTime = now;
                    this.fpsCallback(this.currentFps);
                }

                this.animationFrameId = requestAnimationFrame(this.loop.bind(this));
            }
        }

        /**
         * The main Game class, orchestrating all game components.
         */
        class Game {
            /**
             * Creates an instance of Game.
             */
            constructor() {
                /** @type {HTMLCanvasElement} */
                this.canvas = /** @type {HTMLCanvasElement} */ (document.getElementById('gameCanvas'));

                /**
                 * The 2D array representing the game's background map.
                 * Each number corresponds to a sprite ID in the background spritesheet.
                 * @type {number[][]}
                 */
                this.background = [
                    [44, 45, 29, 28, 29, 28, 29, 35, 35, 28],
                    [28, 29, 35, 7, 8, 9, 0, 2, 35, 12],
                    [1, 2, 35, 23, 24, 25, 32, 18, 35, 28],
                    [33, 17, 2, 35, 35, 35, 35, 16, 2, 12],
                    [35, 16, 18, 35, 35, 35, 0, 17, 34, 28],
                    [1, 17, 18, 115, 35, 115, 32, 34, 115, 12],
                    [33, 33, 34, 35, 115, 35, 115, 115, 115, 28],
                    [13, 12, 13, 12, 13, 115, 115, 115, 115, 12],
                ];

                // Scale the canvas resolution based on map dimensions and GameConfig.CANVAS_SCALE
                this.canvas.width = 10 * GameConfig.SPRITE_WIDTH * GameConfig.CANVAS_SCALE;
                this.canvas.height = 9 * GameConfig.SPRITE_HEIGHT * GameConfig.CANVAS_SCALE;


                /** @type {AssetManager} */
                this.assetManager = new AssetManager();
                /** @type {InputManager} */
                this.inputManager = new InputManager();

                // Load game assets
                /** @type {HTMLImageElement} */
                this.backgroundSpritesheet = this.assetManager.loadImage('background', 'tilesets/background.png');
                /** @type {HTMLImageElement} */
                this.lonkSpritesheet = this.assetManager.loadImage('lonk', 'tilesets/lonk.png');

                /** @type {Lonk} */
                this.lonk = new Lonk(75, 75); // Lonk's positions remain in the unscaled game coordinates


                /**
                 * An array of sprite IDs that are considered solid for collision detection.
                 * @type {number[]}
                 */
                this.solidTiles = [8, 11, 12, 13, 14, 15, 28, 29, 30, 31, 44, 45, 159];

                /**
                 * The current calculated Frames Per Second.
                 * @type {number}
                 */
                this.currentFps = 0;
                /** @type {Renderer | null} */
                this.renderer = null;
                /** @type {GameLoop | null} */
                this.gameLoop = null;
            }

            /**
             * Initializes and starts the game. This includes loading assets and
             * setting up the renderer and game loop.
             * @returns {Promise<void>} A promise that resolves when the game has started.
             */
            async start() {
                try {
                    await this.assetManager.loadAll();
                    this.renderer = new Renderer(this.canvas, this.assetManager.getAsset('background'), this.assetManager.getAsset('lonk'));
                    this.gameLoop = new GameLoop(
                        this.update.bind(this),
                        this.render.bind(this),
                        (/** @type {number} */ fps) => { this.currentFps = fps; }
                    );
                    this.gameLoop.start();
                } catch (error) {
                    console.error("Game failed to start due to asset loading errors:", error);
                }
            }

            /**
             * Stops the game loop.
             */
            stop() {
                if (this.gameLoop) {
                    this.gameLoop.stop();
                }
            }

            /**
             * Updates the game state. This method is called at a fixed timestep.
             */
            update() {
                // Pass unscaled canvas dimensions to Lonk's update for consistent game logic
                this.lonk.update(this.inputManager, this.background, this.solidTiles,
                    this.canvas.width / GameConfig.CANVAS_SCALE,
                    this.canvas.height / GameConfig.CANVAS_SCALE - GameConfig.GAME_BAR_HEIGHT * GameConfig.SPRITE_HEIGHT);
                // Add more game update logic here
            }

            /**
             * Renders the game elements to the canvas.
             * @param {number} interpolation - The interpolation factor (0 to 1) for smooth rendering between fixed updates.
             */
            render(interpolation) {
                this.renderer.clear();
                this.renderer.drawBackground(this.background);
                this.renderer.drawLonk(this.lonk, interpolation);
                this.renderer.drawFPS(this.currentFps);
            }
        }

        // Entry point: Initialize and start the game when the DOM is fully loaded.
        document.addEventListener('DOMContentLoaded', () => {
            const myGame = new Game();
            myGame.start();
        });
    </script>
</body>